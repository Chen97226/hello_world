# DRAM和PM混合系统上设计并发访问的哈希辅助基数树

##基数树（Radix Tree）&自适应基数树（Adaptive Radix Tree，ART）
+ 基数树
	+ 所有内部节点大小相同
	<img src="155683132_1_201903050645084.jfif" height="300" width="400" />
+ 自适应基数树
	+ 根据子节点数量的不同使用几种不同大小内部节点
	+ 当一个内部节点的父节点只有一个子节点时进行路径压缩
	<img src="图片2.emf" height="300" width="400" />


|B树/B+树变种  | 基数树变种
------------- | ------------
纯PM|CDDS B Tree、NV-Tree| WORT、WOART
DRAM、PM混合  | FPTree|HART

对于持久性B树/B+树来说
**性能：有序键值>无序键值**
**一致性开销：有序键值<无序键值**
**基数树不存在这个问题：用键存放的位置表示键的值**

## HART总结
+ hash辅助的ART
+ 选择性持久化
+ 并发访问
+ 增强的内存分配器
+ 支持不同大小的内部节点
+ 防止内存泄漏

## 设计方法
### 1.hash和自适应基数树结合
+ 使用hash表管理ART，每一个hash值对应一个ART
+ 每个键分为两部分：hash部分和ART部分
<img src="图片1.png" height="300" width="400" />

### 2.选择性持久化
+ hash表和ART的内部节点存储在DRAM（**DRAM的性能+有序的键值+无一致性开销**）
+ 叶子节点放在PM上，完整的key也放在叶子节点中，便于一致性恢复

### 3.并发访问	
+ 树粒度的锁，最高并行度为树的个数

### 4.增强的内存分配器
+ 单独实现一个内存分配器，一次性申请多个叶子或者值的节点，提高申请效率
+ 使用位示图表示节点是否使用
+ 把记录下一个叶子或者值节点的信息放在申请的memory chunk中，为崩溃一致性恢复提供保障，减少性能开销
+ 只有当叶子节点成功插入到书中时，位示才会更改，能够防止内存泄漏
<img src="图片4.emf" height="300" width="400" />
<img src="图片5.png" height="300" width="400" />

## 算法
### 插入算法
1. 把键值分成hash部分和和ART部分，根据hash部分找到对应的ART树
2. 使用增强的分配器为叶节点和值节点申请PM空间
3. 更新值节点，**持久化值节点**
4. 把叶子节点指向值节点，**持久化叶子节点**
5. 更改值节点的位示图
6. 更新叶子节点的key，并将其持久化
7. 把叶子结点插入到ART中
8. 更改叶子节点的位示图

### 崩溃恢复
1.插入开始
+ 更改值节点
+ 更改叶子节点指针

**2.设置值的位示图**
+ 设置叶子节点key值

**3.插入到ART中**
**4.设置叶子节点位示图**
5.插入结束

崩溃发生在2之前：无需额外操作
崩溃发生在2-3之间，下次调用增强的持久内存分配器时会自动检测修复不一致状态
崩溃发生在3-4之间，下次调用查找函数会修复不一致状态



## github开源代码链接
https://github.com/CASL-SDSU/HART


